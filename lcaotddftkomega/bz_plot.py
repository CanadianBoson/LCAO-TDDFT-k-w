import matplotlib.pyplot as plt
import matplotlib.tri as tri
import numpy as np
import time
from pandas import DataFrame

# Before running this code to obtain Brillouin zone plots of the oscillator
# strengths, make sure the following files are present:
#  (1) The GPAW calculation file (.gpw)
#  (2) The transitions file: generated by adding the options -t -ct=###
#       to the LCAO-TDDFT-k-w method (.dat)

# Currently, this code supports hexagonal and orthorhombic unit cells only.
# Note that if a 3D cell is inserted into the code, all oscillator strengths
# along the k_z axis will project down to the plane, yielding a 2D projection
# contour map. This can be easily tweaked in the weighted_transitions() method
# to yield cross-sectional plots as well.

# Commands should be run in the following order (alternatively, one can run full_plot):
#  (1) bz_arrays()
#  (2) transition_data()
#  (2a) relevant_bands() (optional)
#  (3) weighted_transitions()
#  (4) bzplot()

# npy files are saved at each stage of the process so at a given energy
# commands do not need to be re-run


def full_plot(transitionsfile, energy, energy_radius=0.2, eta=0.1, time_step=False,
              shape="orthorhombic", dashed_outline=True, mask=True):
    # Will generate full Brillouin zone plot at a given energy when red a transitions file

    transition_data(transitionsfile, energy, energy_radius, time_step)
    weighted_transitions(energy, 'oscillator_strengths.npy', eta, time_step)
    bzplot(shape, 'weighted_transitions.npy', dashed_outline, mask)


def bz_arrays(gpaw_file):
    # This function saves the necessary BZ information into npy arrays, mainly:
    #  (1) An array of Brillouin zone k-points, labeled as 'bz_k_points.npy'
    #  (2) An array of mappings from the irreducible BZ (IBZ)
    #      to the reducible BZ (RBZ), labeled as 'bz_to_ibz_map.npy'

    # gpaw_file: your GPAW calculation file (.gpw)

    from gpaw import GPAW
    calc = GPAW(gpaw_file)
    np.save('bz_k_points.npy', np.array(calc.wfs.kd.bzk_kc))
    np.save('bz_to_ibz_map.npy', np.array(calc.wfs.kd.bz2ibz_k))


def transition_data(transitionsfile, energy, energy_radius=0.2, time_step=False):
    # This function extracts from the LCAO-TDDFT-k-w generated transitions
    # file the transitions within a certain energy range

    # transitions file: generated by adding the options -t -ct=### to the LCAO-TDDFT-k-w method.
    # 1e-10 is the recommended cutoff for transitions to obtain smoother contours
    # energy: centre of desired energy range for Brillouin zone plot (eV)
    # energy_radius: radius of energy range (eV)
    # time_step: output running time per computation, useful for larger transitions files

    transitionsdata = open(transitionsfile, 'r').readlines()
    axesdirs = {'x': 0, 'y': 1, 'z': 2}
    transitionslist = []
    for i in range(1, len(transitionsdata)):
        start = time.time()
        tdata = np.array(transitionsdata[i].strip('[').split(']')[0].split(','), dtype=float)
        e_n, f_nn = tdata[:2]
        i_n, j_n, s_n, kpt_n = np.array(tdata[2:], dtype=int)
        axes_n = axesdirs[transitionsdata[i].split()[-1]]
        if(float(e_n) > float(energy)-float(energy_radius)
            and float(e_n) < float(energy)+float(energy_radius)):
            transitionslist.append([e_n, f_nn, i_n, j_n, s_n, kpt_n, axes_n])
        if(time_step):
             end = time.time()
             print('Transition #{}, Time: {}s'.format(i, end - start))

    data = sorted(transitionslist, key=lambda x: x[1])
    np.save('oscillator_strengths.npy', data) 
    # We note that no broadening of the oscillator strengths is present in this file


def relevant_bands(npy_file='oscillator_strengths.npy', matrix_size=20, rounding_factor=1000):
    # This function shows a matrix with the most relevant m --> n
    # (valence --> conduction) band transitions

    # npy_file: the oscillator_strengths.npy file generated in the transition_data() method

    # matrix_size: the width of the matrix (int); an error will occur if transitions occur 
    # for band number > matrix_size

    # rounding_factor: this will make the results more presentable, especially if a large
    # transition matrix is used

    mat=np.zeros(shape=(int(matrix_size), int(matrix_size)))
    data = np.load(npy_file)
    for i in range(0, len(data)):
        x = int(data[i][2])
        y = int(data[i][3])
        mat[x][y] += data[i][5]

    mat = np.round(mat/int(rounding_factor), 2) 
    print(DataFrame(mat).to_string())


def weighted_transitions(energy, npy_file='oscillator_strengths.npy', eta=0.1, time_step=False):
    # This function weighs the oscillator strengths and assigns them their appropriate place in the BZ

    # npy_file: the oscillator_strengths.npy file generated in the transition_data() method
    # energy: centre of desired energy range for Brillouin zone plot (eV)
    # eta: Lorentz broadening parameter (eV); eta=0.0 will give no broadening
    # time_step: output running time per computation, useful for larger transitions files

    bz_k_points = np.load('bz_k_points.npy')
    k_map = np.load('bz_to_ibz_map.npy')
    transitions = np.load('oscillator_strengths.npy')

    mat=np.zeros(shape=(len(k_map), 3))
    for i in np.arange(0, len(bz_k_points)):
        mat[i] = [bz_k_points[i][0], bz_k_points[i][1], 0.0] #Points x,y, and summed up transitions

    for j in np.arange(0, len(transitions)):
        start = time.time()
        index = [i for i, x in enumerate(k_map) if x==int(transitions[j, 5])] #Find transition at a given k-point
        for i in index:
            # Transitions are multiplied by k_weight, so divide it out when expanding cell to RBZ
            if(float(eta)==0.0):
                mat[i][2] += transitions[j, 1]/float(len(index)) # Broadening turned off
            else:
                mat[i][2] += (float(eta)**2/((transitions[j, 0]-float(energy))**2 + 
                              float(eta)**2))*transitions[j, 1]/float(len(index)) 
        if(time_step):
            end = time.time()
            print('BZ Point #{}, Time: {}s'.format(j, end - start))
    np.save('weighted_transitions.npy', mat)    


def connectpoints(x, y, p1, p2, ax):
    # This function creates the dashed outline around the BZ

    x1, x2 = x[p1], x[p2]
    y1, y2 = y[p1], y[p2]
    ax.plot([x1, x2], [y1, y2], 'k--')


def brillouinplot_orthorhombic(mat, ax, dashed_outline=True):
    # This function creates a contour plot for an orthorhombic unit cell.
    # python3 is required for these contours to be generated

    # mat: the weighted_transitions file (.npy)
    # ax: plot (subplot) environment
    # dashed_outline: create a dashed outline around the BZ plot

    npts = len(mat)
    ngridx = 800
    ngridy = 800
    x = mat[:, 0]
    y = mat[:, 1]
    z = mat[:, 2]

    xi = np.linspace(-0.85, 0.85, ngridx)
    yi = np.linspace(-0.85, 0.85, ngridy)

    triang = tri.Triangulation(x, y)
    interpolator = tri.LinearTriInterpolator(triang, z)
    Xi, Yi = np.meshgrid(xi, yi)
    zi = interpolator(Xi, Yi)
    cntr1 = ax.contourf(xi, yi, zi, levels=30, cmap='Purples')

    # Create a dashed outline around the BZ plot
    if(dashed_outline):
        x=[0.5 , -0.5, -0.5, 0.5]
        y=[0.5, 0.5, -0.5, -0.5]
        rect_verts = [(x[i], y[i]) for i in range(len(x))]

        connectpoints(x, y, 0, 1, ax)
        connectpoints(x, y, 1, 2, ax)
        connectpoints(x, y, 2, 3, ax)
        connectpoints(x, y, 3, 0, ax)

    ax.axis((-0.6, 0.6, -0.6, 0.6))


def brillouinplot_hexagonal(mat, ax, dashed_outline=True, mask=True):
    # This function creates a contour plot for a hexagonal unit cell.
    # python3 is required for these contours to be generated

    # mat: the weighted_transitions file (.npy)
    # ax: plot (subplot) environment
    # dashed_outline: create a dashed outline around the BZ plot
    # mask: mask all transitions beyond the contours; 
    # set to False for cool looking plots

    # This utilizes the 6-fold symmetry of the graphene BZ to superimpose
    # data rotated 120 and 240 degrees

    npts = len(mat)
    ngridx = 800
    ngridy = 800
    x = mat[:, 0]+1.0/2.0*mat[:, 1]
    y = np.sqrt(3)/2.0*mat[:, 1]
    z = mat[:, 2]

    x2 = x*np.cos(np.pi/3.0)+y*np.sin(np.pi/3.0)
    y2 = -x*np.sin(np.pi/3.0)+y*np.cos(np.pi/3.0)
    x = np.append(x, x2)
    y = np.append(y, y2)
    z = np.append(z, z)

    x2 = x*np.cos(2.0*np.pi/3.0)+y*np.sin(2.0*np.pi/3.0)
    y2 = -x*np.sin(2.0*np.pi/3.0)+y*np.cos(2.0*np.pi/3.0)
    x = np.append(x, x2)
    y = np.append(y, y2)
    z = np.append(z, z)

    xi = np.linspace(-0.85, 0.85, ngridx)
    yi = np.linspace(-0.85, 0.85, ngridy)

    triang = tri.Triangulation(x, y)
    interpolator = tri.LinearTriInterpolator(triang, z)
    Xi, Yi = np.meshgrid(xi, yi)
    zi = interpolator(Xi, Yi)

    cntr1 = ax.contourf(xi, yi, zi, levels=30, cmap='Purples')

    # Make sure these vertices go counter-clockwise for mask_outside_polygon to work
    x = [0.3333+1.0/2.0*0.3333, 0.0, -0.3333-1.0/2.0*0.3333,
      -0.3333-1.0/2.0*0.3333, 0.0, 0.3333+1.0/2.0*0.3333]
    y = [np.sqrt(3)/2.0*0.3333, 1.0/np.sqrt(3), np.sqrt(3)/2.0*0.3333,
     - np.sqrt(3)/2.0*0.3333, -1.0/np.sqrt(3), - np.sqrt(3)/2.0*0.3333]
    hexagon_verts = [(x[i], y[i]) for i in range(len(x))]

    if(mask):
        mask_outside_polygon(hexagon_verts, ax)

    if(dashed_outline):
        connectpoints(x, y, 0, 1, ax)
        connectpoints(x, y, 1, 2, ax)
        connectpoints(x, y, 2, 3, ax)
        connectpoints(x, y, 3, 4, ax)
        connectpoints(x, y, 4, 5, ax)
        connectpoints(x, y, 5, 0, ax)

    ax.axis((-0.6, 0.6, -0.6, 0.6))


def bzplot(shape="orthorhombic", npy_file='weighted_transitions.npy', dashed_outline=True, mask=True):
    # Output a single BZ plot to window

    mat = np.load(npy_file)
    if(shape == 'orthorhombic'):
        brillouinplot_orthorhombic(mat, plt, dashed_outline)
    if(shape == 'hexagonal'):
        brillouinplot_hexagonal(mat, plt, dashed_outline, mask)
    plt.axis('off')
    plt.show()


def mask_outside_polygon(poly_verts, ax=None): 
    # Plots a mask on the specified axis ("ax", defaults to plt.gca()) such that
    # all areas outside of the polygon specified by "poly_verts" are masked 
    # This method is necessary for any non-orthorhombic BZ plots
    # Credit goes to: 
    # https://stackoverflow.com/questions/3320311/fill-outside-of-polygon-mask-array-where-indicies-are-beyond-a-circular-bounda

    # "poly_verts" must be a list of tuples of the verticies in the polygon in
    # counter-clockwise order

    # Returns the matplotlib.patches.PathPatch instance plotted on the figure

    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib.patches as mpatches
    import matplotlib.path as mpath

    if ax is None:
        ax = plt.gca()

    if(ax == plt):
        ax = plt.gca()

    # Get current plot limits
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()

    # Verticies of the plot boundaries in clockwise order
    bound_verts = [(xlim[0], ylim[0]), (xlim[0], ylim[1]), 
                   (xlim[1], ylim[1]), (xlim[1], ylim[0]), 
                   (xlim[0], ylim[0])]

    # A series of codes (1 and 2) to tell matplotlib whether to draw a line or 
    # move the "pen" (So that there's no connecting line)
    bound_codes = [mpath.Path.MOVETO] + (len(bound_verts) - 1) * [mpath.Path.LINETO]
    poly_codes = [mpath.Path.MOVETO] + (len(poly_verts) - 1) * [mpath.Path.LINETO]

    # Plot the masking patch
    path = mpath.Path(bound_verts + poly_verts, bound_codes + poly_codes)
    patch = mpatches.PathPatch(path, facecolor='white', edgecolor='none')
    patch = ax.add_patch(patch)

    # Reset the plot limits to their original extents
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)

    return patch